<!-- XMLBible.html
 - James Skon: original version April 2011
 - Bob Kasper: revised March 2021
 - Benjamin Leskey: revised March-April 2021
 - Mount Vernon Nazarene University
 -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>XML Bible Demo - MVNU</title>
		<style type="text/css">
			body {
				background: #eee;
			}

			.container {
				display: flex;
			}

			.information {
				padding-bottom: 1vh;
			}

			.information > h1 {
				text-align: center;
				font-size: 1.5em;
				padding: 0;
				margin: 0;
			}

			.information > div {
				overflow: auto;
				max-height: 45vh;
			}

			.horizontal {
				flex-direction: row;
			}

			.vertical {
				flex-direction: column;
			}

			.wide {
				min-width: 60%;
			}
		</style>

		<script type="text/javascript">
			function setup() {
				// location of XML Bible files, must be on same web server
				// that hosts this web page to avoid Cross-Domain request restrictions
				biblePath = "/class/csc3004/XMLBible";

				// Map of human-readable version identifiers to server Bible names.
				bibles = {
					"kjv": "kjv",
					"web": "web",
				};

				// Which book is the start of the New Testament?
				startOfNT = 40;

				// Array of book names.
				bookNames = [
					"Genesis",
					"Exodus",
					"Leviticus",
					"Numbers",
					"Deuteronomy",
					"Joshua",
					"Judges",
					"Ruth",
					"1 Samuel",
					"2 Samuel",
					"1 Kings",
					"2 Kings",
					"1 Chronicles",
					"2 Chronicles",
					"Ezra",
					"Nehemiah",
					"Esther",
					"Job",
					"Psalms",
					"Proverbs",
					"Ecclesiastes",
					"Song of Solomon",
					"Isaiah",
					"Jeremiah",
					"Lamentations",
					"Ezekiel",
					"Daniel",
					"Hosea",
					"Joel",
					"Amos",
					"Obadiah",
					"Jonah",
					"Micah",
					"Nahum",
					"Habakkuk",
					"Zephaniah",
					"Haggai",
					"Zechariah",
					"Malachi",
					"Matthew",
					"Mark",
					"Luke",
					"John",
					"Acts",
					"Romans",
					"1 Corinthians",
					"2 Corinthians",
					"Galatians",
					"Ephesians",
					"Philippians",
					"Colossians",
					"1 Thessalonians",
					"2 Thessalonians",
					"1 Timothy",
					"2 Timothy",
					"Titus",
					"Philemon",
					"Hebrews",
					"James",
					"1 Peter",
					"2 Peter",
					"1 John",
					"2 John",
					"3 John",
					"Jude",
					"Revelation",
				];

				// Build selection options from book names.
				for(var i = 0; i < bookNames.length; i++) {
					var book_select = document.getElementById("book");
					book_select.innerHTML += "<option value='" + (i + 1) + "'>" + bookNames[i];
				}

				// Load the concordances.
				concordanceHebrew = getXMLDoc(biblePath + "/bible_refs_of_strongs_numbers/bible_refs_by_strongs_num_ot.xml");
				concordanceGreek = getXMLDoc(biblePath + "/bible_refs_of_strongs_numbers/bible_refs_by_strongs_num_nt.xml");
			}

			function makeXMLHttpRequest() {
				if (window.XMLHttpRequest) {
					// Modern browsers (IE7+, Chrome, Firefox, etc.)
					return new XMLHttpRequest();
				}
				else {
					// Ancient browsers (IE5-6)
					return new ActiveXObject("Microsoft.XMLHTTP");
				}
			}

			// Get XML from a path on the web server.
			function getXMLDoc(path) {
				var xmlhttp = makeXMLHttpRequest();
				xmlhttp.open("GET", path, false);
				xmlhttp.send();
				return xmlhttp.responseXML;
			}

			// Get the server path to the book XML for the specified bible version and book number.
			function getBookPath(version, book) {
				if(version in bibles) {
					return biblePath + "/" + bibles[version] + "_by_book/" + book + ".xml";
				}
				else {
					throw "no version";
				}
			}

			// Get the server path to the Strong's dictionary XML for the specified language and Strong's number.
			function getStrongsPath(language, number) {
				// Get file index number.
				// 0 is 1-100, 1 is 101-200, etc.
				var indexNumber = Math.trunc((number - 1) / 100);
				if(language == "hebrew") {
					return biblePath + "/" + "heb_strongs/heb" + indexNumber + ".xml";
				}
				else if(language == "greek") {
					return biblePath + "/" + "greek_strongs/grk" + indexNumber + ".xml";
				}
				else {
					throw ("bad language: " + language);
				}
			}

			// Get the index of a number in the appropriate Strong's dictionary list of item elements.
			function getStrongsIndex(language, number) {
				return (number - 1) % 100;
			}

			// Get the strongs concordance for a language.
			function getStrongsConcordance(language) {
				if(language == "hebrew") {
					return concordanceHebrew;
				}
				else if(language == "greek") {
					return concordanceGreek;
				}
				else {
					throw ("bad language: " + language);
				}
			}

			// Get the concordance item for a strongs number and language.
			// Returns null if it is not found.
			function getStrongsConcordanceItem(language, number) {
				return getStrongsConcordance(language).querySelector("item[number='" + number + "']");
			}

			// Get the currently selected version.
			function getCurrentVersion() {
				return document.getElementById("version").value;
			}

			// Handle the form submission.
			function getResponse() {
				// Get input values from the form.
				var version = getCurrentVersion();
				var b = parseInt(document.getElementById("book").value);
				var c = parseInt(document.getElementById("chapter").value);
				var v = parseInt(document.getElementById("verse").value);
				var nv = parseInt(document.getElementById("versenum").value);

				// Display the verses.
				openVerses(version, b, c, v, nv);
			}

			function getNextSiblingOfTag(element, tag) {
				var next = element.nextSibling;
				while(next != null && next.nodeType != 1 && next.nodeName != tag) {
					next = next.nextSibling;
				}
				return next;
			}

			function getChapterHeader(xmlDoc, b, c) {
				var book = xmlDoc.getElementsByTagName("book")[0];
				if (book == null)
					throw "no book";
				var chapter = book.getElementsByTagName("chapter")[c - 1];
				if(chapter == null)
					throw "no chapter";
				return book.getAttribute("name") + " " + chapter.getAttribute("number");
			}

			// Get the default language (hebrew or greek) for the specified book.
			function getBookDefaultLanguage(b) {
				// OT is hebrew, NT is greek.
				return (b < startOfNT ? "hebrew" : "greek");
			}

			// Get the human-readable name of a book.
			function getBookName(b) {
				// Convert to array index.
				var index = b - 1;
				return (index >= 0 && index < bookNames.length) ? bookNames[index] : "Invalid";
			}

			// Get <count> verses starting at b:c:v.
			// b is irrelevant here, as the book that is loaded in xmlDoc will always be b.
			function getVerses(xmlDoc, b, c, v, count) {
				// Array of verse descriptors to be returned.
				var result = [];

				// Start out at the specified bible reference.

				// Current book element.
				// Always the first book element in the xmlDoc.
				var book = xmlDoc.getElementsByTagName("book")[0];
				if (book == null)
					throw "no book";

				// Current chapter element.
				var chapter = book.getElementsByTagName("chapter")[c - 1];
				if (chapter == null)
					throw "no chapter";

				// Current verse element.
				var verse = chapter.getElementsByTagName("verse")[v - 1]
				if (verse == null)
					throw "no verse";

				// Current chapter number.
				var c_current = c;

				// Fetch at most <count> verses.
				for(var i = 0; i < count; i++) {
					// Push a verse descriptor with reference numbers and rendered text.
					result.push({
						"b": b,
						"c": c_current,
						"v": parseInt(verse.getAttribute("number")),
						// Rendered text with appropriate context.
						"text": renderElement(verse, {
							"type": "verse",
							"language": getBookDefaultLanguage(b),
						}),
					});

					// Find the next verse, or break out if there's no next verse.
					verse = getNextSiblingOfTag(verse, "verse");
					if(verse == null) {
						// No next verse, try next chapter.
						chapter = getNextSiblingOfTag(chapter, "chapter");
						if(chapter == null) {
							// No next chapter, we're done.
							break;
						}
						else {
							// Update chapter number and get first verse of the new chapter.
							c_current = parseInt(chapter.getAttribute("number"));
							verse = chapter.getElementsByTagName("verse")[0];
							if(verse == null) {
								// No first verse -- weird; we're done here.
								break;
							}
						}
					}
				}

				return result;
			}

			// Get an element rendered as HTML with automatically processed whitespacing.
			// Passes render_context to getNodeRendered for rendering.
			function renderElement(element, render_context) {
				var text = "";

				// Render each node inside the element.
				// Parse punctuation with regex to perform the correct spacing.
				var was_punctuation_before = true; // Was there punctuation before the current node?
				for(const node of element.childNodes) {
					// Render the node.
					var rendering = getNodeRendered(node, render_context);

					// Check if this is punctuation that needs no space before it.
					var is_punctuation = /^[,.?\-"':;” ]/.test(rendering["base_text"]);

					// Place the node into the text.
					// Including leading space unless this node is punctuation that needs no space or has punctuation that doesn't want a trailing space before it.
					text += ((is_punctuation || was_punctuation_before) ? "" : " ") + rendering["text"];

					// Check if this node means that there doesn't need to be a space for the next node (opening quote, for example.)
					was_punctuation_before = /[“ ]+$/.test(rendering["base_text"]);
				}

				return text;
			}

			// Get a concordance item rendered as HTML.
			// Passes render_context to getNodeRendered for rendering.
			function renderConcordanceItem(element, render_context) {
				var text = "<ul class='reference_list'>";

				// Render each node (reference) in the concordance item.
				// Add it to the list display.
				for(const node of element.childNodes) {
					var rendering = getNodeRendered(node, render_context);
					text += "<li>" + rendering["text"] + "</li>";
				}

				text += "</ul>";
				return text;
			}

			// Open a display of the given verses.
			function openVerses(version, b, c, v, num_verses) {
				var text = "";

				try {
					// Get the XML doc for this request.
					var xmlDoc = getXMLDoc(getBookPath(version, b));

					// Check top level error.
					if(xmlDoc == null)
						throw "no book";

					// Show the verses.
					var current_chapter = -1;
					for(const verse of getVerses(xmlDoc, b, c, v, num_verses)) {
						// Display header if the chapter changes.
						if(verse["c"] != current_chapter) {
							text += "<h2>" + getChapterHeader(xmlDoc, verse["b"], verse["c"]) + "</h2>";
							current_chapter = verse["c"];
						}

						// Display the verse.
						text += "<p><em>" + verse["v"] + ".</em> " + verse["text"] + "</p>";
					}
				}
				catch(error) {
					if (error == "no book") {
						text += "<b><i>No such book " + b + "</i></b>";
					}
					else if (error == "no chapter") {
						text += "<b><i>No such chapter " + c + "</i></b>";
					}
					else if (error == "no verse") {
						text += "<b><i>No such verse " + v + "</i></b>";
					}
					else {
						text += "<b><i>Internal error: " + error + "<i></b>";
						console.log(error);
					}
				}

				// Update display.
				document.all.responseArea.innerHTML = text;
			}

			// Open a display of the Strong's reference and concordance for the language and strongs number.
			// Language will be either "hebrew" or "greek".
			function openStrongs(language, number) {
				// Display the content.
				openStrongsDisplay(language, number);
				openConcordanceDisplay(language, number);
				// Enable the side pane with the information.
				document.getElementById("strongsInformation").style.visibility = "visible";
			}

			// Open a display of the Strong's reference for the language and number.
			function openStrongsDisplay(language, number) {
				try {
					// Get the XML Dictionary.
					var dictionary = getXMLDoc(getStrongsPath(language, number));
					// Get the dictinoary entry.
					var element = dictionary.getElementsByTagName("item")[getStrongsIndex(language, number)];

					// Build the display from each sub element.
					var text = "";
					var render_context = {
						"type": "strongs",
						"language": language,

					}

					var strong_id = element.getElementsByTagName("strong_id")[0];
					if(strong_id) {
						text += "<h2>" + renderElement(strong_id, render_context) + "</h2>";
					}

					var title = element.getElementsByTagName("title")[0];
					if(title) {
						text += "<h2>" + renderElement(title, render_context) + "</h2>";
					}

					var transliteration = element.getElementsByTagName("transliteration")[0];
					if(transliteration) {
						text += "<p>Transliterated: " + renderElement(transliteration, render_context) + "</p>";
					}

					var pronunciation = element.getElementsByTagName("pronunciation")[0];
					if(pronunciation) {
						text += "<p>Pronounced: " + renderElement(pronunciation, render_context) + "</p>";
					}

					var description = element.getElementsByTagName("description")[0];
					if(description) {
						text += "<p>" + renderElement(description, render_context) + "</p>";
					}

					document.getElementById("strongsArea").innerHTML = text;
				}
				catch(error) {
					document.getElementById("strongsArea").innerHTML = "<b><i>Internal error: " + error + "</i></b>";
					console.log(error);
				}
			}

			// Open a display of the Strong's concordance for the language and number.
			function openConcordanceDisplay(language, number) {
				try {
					var item = getStrongsConcordanceItem(language, number);
					if(item != null) {
						document.getElementById("referencesArea").innerHTML = renderConcordanceItem(item, {
							"type": "concordance_item",
							"language": language,
						});
					}
				}
				catch(error) {
					document.getElementById("referencesArea").innerHTML = "<b><i>Internal error: " + error + "</i></b>";
					console.log(error);
				}
			}

			/* Get a rendering of the text inside the node.
			The render context specifies global attributes of the text being rendered.
				type: "verse" or "strongs"
				language: default language of any Strong's references, "greek" or "hebrew"
			*/
			function getNodeRendered(node, render_context) {
				// Fully rendered HTML result.
				var result = "";
				// Only the text parts.
				var base_result = "";

				// Recursively render a sub node.
				// Updates result and base_result.
				function renderSubNode(node) {
					for(const child of node.childNodes) {
						var rendered = getNodeRendered(child, render_context);
						base_result += rendered["base_text"];
						result += rendered["text"];
					}
				}

				if (node.nodeType == 3) {
					// type 3: text node, just display
					result += node.nodeValue;
					base_result = result;
				}
				else if (node.nodeType == 1) {
					// type 1: tag, parse it
					// Canonicalize tag names.
					var tagName = node.nodeName.toLowerCase();
					// Render context type.
					var rt = render_context["type"];

					if (tagName == "em") {
						result += "<i>";
						renderSubNode(node);
						result += "</i>";
					}
					else if(tagName == "strong") {
						result += "<b>";
						renderSubNode(node);
						result += "</b>";
					}
					else if (tagName == "style") {
						result += '<span style="' + node.getAttribute("css") + '">';
						renderSubNode(node);
						result += "</span>";
					}
					else if (rt == "verse" && tagName == "note") {
						if(document.getElementById("include_notes").checked) {
							result += "<sub>";
							renderSubNode(node);
							result += "</sub>";
						}
					}
					else if (rt == "verse" && tagName == "strongs") {
						// Word with a Strong's reference, render the word and include links after it if enabled.
						renderSubNode(node);

						if(document.getElementById("include_strongs").checked) {
							// Get and display the Strong's number, with callbacks to the click event handler.

							var language = ""; // Which language? "greek" or "hebrew"
							var numbers = ""; // Strongs number(s), there can be multiple in one attribute as in KJV 2 Samuel 5:2.

							if(node.hasAttribute("hebrew")) {
								language = "hebrew";
								numbers = node.getAttribute("hebrew");
							}
							else if(node.hasAttribute("greek")) {
								language = "greek";
								numbers = node.getAttribute("greek");
							}
							else if(node.hasAttribute("number")) {
								// If the attribute is just called number, use the render context to determine what the language should be.
								language = render_context["language"];
								numbers = node.getAttribute("number");
							}
							else {
								throw "no strongs number in strongs element";
							}

							result += "<sub>";

							// Render links to each number.
							var links = [];
							for(const number of numbers.split(" ")) {
								// Number as actual integer, maybe stripping leading '*'.
								var integer = parseInt(number.replace("*", ""));

								links.push("<a href='javascript:openStrongs(\"" + language + "\", " + integer + ")'>" + number + "</a>");
							}
							// Join links with spaces between.
							result += links.join(" ");

							result += "</sub>";
						}
					}
					else if(rt == "strongs" && node.nodeName == "link") {
						// Link to a Strongs reference, render as hyperlink.

						if(node.hasAttribute("target")) {
							var reference = node.getAttribute("target");
							// Parse reference.
							var language = (reference.charAt(0) == "H" ? "hebrew" : "greek");
							var number = parseInt(reference.substring(1));
							// Make link.
							result += "<a href='javascript:openStrongs(\"" + language + "\", " + number + ")'>";
						}

						renderSubNode(node);

						if(node.hasAttribute("target")) {
							result += "</a>";
						}
					}
					else if(rt == "concordance_item" && node.nodeName == "ref") {
						// Link to a verse, render as hyperlink.
						var b = parseInt(node.getAttribute("b"));
						var c = parseInt(node.getAttribute("ch"));
						var v = parseInt(node.getAttribute("v"));

						result += "<a href='javascript:openVerses(\"" + getCurrentVersion() + "\", " + b + "," + c + "," + v + ", 1)'>";
						result += getBookName(b) + " " + c + ":" + v;
						result += "</a>";
					}
					else {
						// Unknown element, render as plain text node.
						renderSubNode(node);
					}
				}

				// Return all information about the rendering & results.
				return {
					"text": result,
					"base_text": base_result,
				};
			}
		</script>
	</head>

	<body onLoad="setup()">
		<div class="container horizontal">
			<div class="container vertical wide">
				<div>
					<form onsubmit="return false">
						<h1>Bible Search from XML files</h1>
						<table>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Bible Version</TD>
								<TD ALIGN=LEFT VALIGN=TOP>
									<select name="version" id="version">
										<option value="kjv">King James Version
										<option value="web">World English Bible
									</select>
								</TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Book Number</TD>
								<TD ALIGN=LEFT VALIGN=TOP><select name="book" id="book"></select></TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Chapter</TD>
								<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="chapter" TYPE="text" MAXLENGTH=3  id=chapter></TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Verse</TD>
								<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="verse" TYPE="text" MAXLENGTH=3 id=verse></TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Number of Verses</TD>
								<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="versenum" TYPE="text" MAXLENGTH=3 id=versenum></TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Include Strong's References</TD>
								<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="include_strongs" id=include_strongs type="checkbox"></TD>
							</TR>
							<TR>
								<TD ALIGN=RIGHT VALIGN=TOP>Include Notes</TD>
								<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="include_strongs" id=include_notes type="checkbox" checked></TD>
							</TR>
						</table>
						<p>
							<input type="submit" onclick="javascript: getResponse()" name="submit" value="Submit" />
						</p>
					</form>
				</div>
				<div id="responseArea">
				</div>
			</div>
			<div id="strongsInformation" class="container vertical" style="visibility: hidden;">
				<div id="strongsParent" class="information">
					<h1>Lexicon</h1>
					<div id="strongsArea">
					</div>
				</div>
				<div id="referencesParent" class="information">
					<h1>Concordance</h1>
					<div id="referencesArea">
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
