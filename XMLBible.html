<!-- XMLBible.html
 - James Skon: original version April 2011
 - Bob Kasper: revised March 2021
 - Benjamin Leskey: revised March 2021
 - Mount Vernon Nazarene University
 -->
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>XML Bible Demo - MVNU</title>
		<style type="text/css">
			#left {
				max-width: 72%;
			}
			#right {
				position: absolute;
				top: 0;
				right: 0;
				max-width: 25%;
			}
		</style>

		<script type="text/javascript">
			function setup() {
				// location of XML Bible files, must be on same web server
				// that hosts this web page to avoid Cross-Domain request restrictions
				biblePath = "/class/csc3004/XMLBible";

				// Map of human-readable version identifiers to server Bible names.
				bibles = {
					"kjv": "kjv",
					"web": "web",
				};

				// Which book is the start of the New Testament?
				startOfNT = 40;
			}

			function makeXMLHttpRequest() {
				if (window.XMLHttpRequest) {
					// Modern browsers (IE7+, Chrome, Firefox, etc.)
					return new XMLHttpRequest();
				}
				else {
					// Ancient browsers (IE5-6)
					return new ActiveXObject("Microsoft.XMLHTTP");
				}
			}

			// Get XML from a path on the web server.
			function getXMLDoc(path) {
				var xmlhttp = makeXMLHttpRequest();
				xmlhttp.open("GET", path, false);
				xmlhttp.send();
				return xmlhttp.responseXML;
			}

			// Get the server path to the book XML for the specified bible version and book number.
			function getBookPath(version, book) {
				if(version in bibles) {
					return biblePath + "/" + bibles[version] + "_by_book/" + book + ".xml";
				}
				else {
					throw "no version";
				}
			}

			// Get the server path to the Strong's dictionary XML for the specified language and Strong's number.
			function getStrongsPath(language, number) {
				// Get file index number.
				// 0 is 1-100, 1 is 101-200, etc.
				var indexNumber = Math.trunc((number - 1) / 100);
				if(language == "hebrew") {
					return biblePath + "/" + "heb_strongs/heb" + indexNumber + ".xml";
				}
				else if(language == "greek") {
					return biblePath + "/" + "greek_strongs/grk" + indexNumber + ".xml";
				}
				else {
					throw ("bad language: " + language);
				}
			}

			// Get the index of a number in the appropriate Strong's dictionary list of item elements.
			function getStrongsIndex(language, number) {
				return (number - 1) % 100;
			}

			function getResponse () {
				// Get input values from the form.
				var version = document.getElementById("version").value;
				var b = document.getElementById("book").value;
				var c = document.getElementById("chapter").value;
				var v = parseInt(document.getElementById("verse").value);
				var nv = parseInt(document.getElementById("versenum").value);

				// Reset the display.
				document.all.responseArea.innerHTML = " ";

				try {
					// Get the XML doc for this request.
					var xmlDoc = getXMLDoc(getBookPath(version, b));

					// Check top level error.
					if(xmlDoc == null)
						throw "no book";

					// Show the verses.
					var current_chapter = -1;
					for(const verse of getVerses(xmlDoc, b, c, v, nv)) {
						// Display header if the chapter changes.
						if(verse["c"] != current_chapter) {
							document.all.responseArea.innerHTML += "<h2>" + getChapterHeader(xmlDoc, verse["b"], verse["c"]) + "</h2>";
							current_chapter = verse["c"];
						}

						// Display the verse.
						document.all.responseArea.innerHTML += "<p><em>" + verse["v"] + ".</em> " + verse["text"] + "</p>";
					}
				}
				catch(error) {
					if (error == "no book") {
						document.all.responseArea.innerHTML += "<b><i>No such book " + b + "</i></b>";
					}
					else if (error == "no chapter") {
						document.all.responseArea.innerHTML += "<b><i>No such chapter " + c + "</i></b>";
					}
					else if (error == "no verse") {
						document.all.responseArea.innerHTML += "<b><i>No such verse " + v + "</i></b>";
					}
					else {
						document.all.responseArea.innerHTML += "<b><i>Internal error: " + error + "<i></b>";
						console.log(error);
					}
				}
			}

			function getNextSiblingOfTag(element, tag) {
				var next = element.nextSibling;
				while(next != null && next.nodeType != 1 && next.nodeName != tag) {
					next = next.nextSibling;
				}
				return next;
			}

			function getChapterHeader(xmlDoc, b, c) {
				var book = xmlDoc.getElementsByTagName("book")[0];
				if (book == null)
					throw "no book";
				var chapter = book.getElementsByTagName("chapter")[c - 1];
				if(chapter == null)
					throw "no chapter";
				return book.getAttribute("name") + " " + chapter.getAttribute("number");
			}

			// Get the default language (hebrew or greek) for the specified book.
			function getBookDefaultLanguage(b) {
				// OT is hebrew, NT is greek.
				return (b < startOfNT ? "hebrew" : "greek");
			}

			// Get <count> verses starting at b:c:v.
			// b is irrelevant here, as the book that is loaded in xmlDoc will always be b.
			function getVerses(xmlDoc, b, c, v, count) {
				// Array of verse descriptors to be returned.
				var result = [];

				// Start out at the specified bible reference.

				// Current book element.
				// Always the first book element in the xmlDoc.
				var book = xmlDoc.getElementsByTagName("book")[0];
				if (book == null)
					throw "no book";

				// Current chapter element.
				var chapter = book.getElementsByTagName("chapter")[c - 1];
				if (chapter == null)
					throw "no chapter";

				// Current verse element.
				var verse = chapter.getElementsByTagName("verse")[v - 1]
				if (verse == null)
					throw "no verse";

				// Current chapter number.
				var c_current = c;

				// Fetch at most <count> verses.
				for(var i = 0; i < count; i++) {
					// Push a verse descriptor with reference numbers and rendered text.
					result.push({
						"b": b,
						"c": c_current,
						"v": parseInt(verse.getAttribute("number")),
						// Rendered text with appropriate context.
						"text": renderElement(verse, {
							"type": "verse",
							"language": getBookDefaultLanguage(b),
						}),
					});

					// Find the next verse, or break out if there's no next verse.
					verse = getNextSiblingOfTag(verse, "verse");
					if(verse == null) {
						// No next verse, try next chapter.
						chapter = getNextSiblingOfTag(chapter, "chapter");
						if(chapter == null) {
							// No next chapter, we're done.
							break;
						}
						else {
							// Update chapter number and get first verse of the new chapter.
							c_current = parseInt(chapter.getAttribute("number"));
							verse = chapter.getElementsByTagName("verse")[0];
							if(verse == null) {
								// No first verse -- weird; we're done here.
								break;
							}
						}
					}
				}

				return result;
			}

			// Get an element rendered as HTML with automatically processed whitespacing.
			// Passes render_context to getNodeRendered for rendering.
			function renderElement(verse, render_context) {
				var text = "";

				// Render each node inside the verse.
				// Parse punctuation with regex to perform the correct spacing.
				var was_punctuation_before = true; // Was there punctuation before the current node?
				for(const node of verse.childNodes) {
					// Render the node.
					var rendering = getNodeRendered(node, render_context);

					// Check if this is punctuation that needs no space before it.
					var is_punctuation = /^[,.?\-"':;” ]/.test(rendering["base_text"]);

					// Place the node into the text.
					// Including leading space unless this node is punctuation that needs no space or has punctuation that doesn't want a trailing space before it.
					text += ((is_punctuation || was_punctuation_before) ? "" : " ") + rendering["text"];

					// Check if this node means that there doesn't need to be a space for the next node (opening quote, for example.)
					was_punctuation_before = /[“ ]+$/.test(rendering["base_text"]);
				}

				return text;
			}

			// Open a display of the Strong's reference for the language and number.
			// Language will be either "hebrew" or "greek".
			function openStrongs(language, number) {
				try {
					// Get the XML Dictionary.
					var dictionary = getXMLDoc(getStrongsPath(language, number));
					// Get the dictinoary entry.
					var element = dictionary.getElementsByTagName("item")[getStrongsIndex(language, number)];

					// Build the display from each sub element.
					var text = "";
					var render_context = {
						"type": "strongs",
						"language": language,

					}

					var strong_id = element.getElementsByTagName("strong_id")[0];
					if(strong_id) {
						text += "<h2>" + renderElement(strong_id, render_context) + "</h2>";
					}

					var title = element.getElementsByTagName("title")[0];
					if(title) {
						text += "<h2>" + renderElement(title, render_context) + "</h2>";
					}

					var transliteration = element.getElementsByTagName("transliteration")[0];
					if(transliteration) {
						text += "<p>Transliterated: " + renderElement(transliteration, render_context) + "</p>";
					}

					var pronunciation = element.getElementsByTagName("pronunciation")[0];
					if(pronunciation) {
						text += "<p>Pronounced: " + renderElement(pronunciation, render_context) + "</p>";
					}

					var description = element.getElementsByTagName("description")[0];
					if(description) {
						text += "<p>" + renderElement(description, render_context) + "</p>";
					}

					document.getElementById("strongsArea").innerHTML = text;
				}
				catch(error) {
					document.getElementById("strongsArea").innerHTML = "<b><i>Internal error: " + error + "</i></b>";
					console.log(error);
				}
			}

			/* Get a rendering of the text inside the node.
			The render context specifies global attributes of the text being rendered.
				type: "verse" or "strongs"
				language: default language of any Strong's references, "greek" or "hebrew"
			*/
			function getNodeRendered(node, render_context) {
				// Fully rendered HTML result.
				var result = "";
				// Only the text parts.
				var base_result = "";

				if (node.nodeType == 3) {
					// type 3: text node, just display
					result += node.nodeValue;
					base_result = result;
				}
				else if (node.nodeType == 1) {
					// type 1: tag, parse it
					if (node.nodeName == "em") {
						result += "<i>";
						base_result = node.childNodes[0].nodeValue
						result += base_result;
						result += "</i>";
					}
					else if (node.nodeName == "STYLE") {
						result += '<span style="' + node.getAttribute("css") + '">';
						// Recursively render everything that needs to be styled.
						for (n=0; n < node.childNodes.length; n++) {
							var rendered = getNodeRendered(node.childNodes[n], render_context);
							base_result += rendered["base_text"];
							result += rendered["text"];
						}
						result += "</span>";
					}
					else if (node.nodeName == "strongs" && render_context["type"] == "verse") {
						// Word with a Strong's reference.
						if (node.childNodes[0] != null) {
							// Show the word.
							base_result = node.childNodes[0].nodeValue;
							result += base_result;
						}

						if(document.getElementById("include_strongs").checked) {
							// Get and display the Strong's number, with callbacks to the click event handler.

							var language = ""; // Which language? "greek" or "hebrew"
							var numbers = ""; // Strongs number(s), there can be multiple in one attribute as in KJV 2 Samuel 5:2.

							if(node.hasAttribute("hebrew")) {
								language = "hebrew";
								numbers = node.getAttribute("hebrew");
							}
							else if(node.hasAttribute("greek")) {
								language = "greek";
								numbers = node.getAttribute("greek");
							}
							else if(node.hasAttribute("number")) {
								// If the attribute is just called number, use the render context to determine what the language should be.
								language = render_context["language"];
								numbers = node.getAttribute("number");
							}
							else {
								throw "no strongs number in strongs element";
							}

							result += "<sub>";

							// Render links to each number.
							var links = [];
							for(const number of numbers.split(" ")) {
								// Number as actual integer, maybe stripping leading '*'.
								var integer = parseInt(number.replace("*", ""));

								links.push("<a href='javascript:openStrongs(\"" + language + "\", " + integer + ")'>" + number + "</a>");
							}
							// Join links with spaces between.
							result += links.join(" ");

							result += "</sub>";
						}
					}
					else if(node.nodeName == "link" && render_context["type"] == "strongs") {
						// Link to a Strongs reference.
						if(node.hasAttribute("target")) {
							var reference = node.getAttribute("target");
							// Parse reference.
							var language = (reference.charAt(0) == "H" ? "hebrew" : "greek");
							var number = parseInt(reference.substring(1));
							// Make link.
							result += "<a href='javascript:openStrongs(\"" + language + "\", " + number + ")'>";
						}

						if (node.childNodes[0] != null) {
							// Show the word.
							base_result = node.childNodes[0].nodeValue;
							result += base_result;
						}

						if(node.hasAttribute("target")) {
							result += "</a>";
						}
					}
				}

				// Return all information about the rendering & results.
				return {
					"text": result,
					"base_text": base_result,
				};
			}
		</script>
	</head>

	<body onLoad="setup()">
		<div id="left">
			<form onsubmit="return false">
				<h1>Bible Search from XML files</h1>
				<table>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Bible Version</TD>
						<TD ALIGN=LEFT VALIGN=TOP>
							<select name="version" id="version">
								<option value="kjv">King James Version
								<option value="web">World English Bible
							</select>
						</TD>
					</TR>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Book Number</TD>
						<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="book" TYPE="text" MAXLENGTH=2  id=book></TD>
					</TR>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Chapter</TD>
						<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="chapter" TYPE="text" MAXLENGTH=3  id=chapter></TD>
					</TR>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Verse</TD>
						<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="verse" TYPE="text" MAXLENGTH=3 id=verse></TD>
					</TR>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Number of Verses</TD>
						<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="versenum" TYPE="text" MAXLENGTH=3 id=versenum></TD>
					</TR>
					<TR>
						<TD ALIGN=RIGHT VALIGN=TOP>Include Strong's References</TD>
						<TD ALIGN=LEFT VALIGN=TOP><INPUT NAME="include_strongs" id=include_strongs type="checkbox"></TD>
					</TR>
				</table>
				<p>
					<input type="submit" onclick="javascript: getResponse()" name="submit" value="Submit" />
				</p>
			</form>
			<div id="responseArea">
			</div>
		</div>
		<div id="right">
			<div id="strongsArea">
			</div>
		</div>
	</body>
</html>
